///////////// Code to calculate log base 2 of an unsigned int (such as generated by an rng)
#include <stdio.h>
#include <stdint.h>
#include <iostream>
#include <chrono>
#include <string>
#include <inttypes.h> // for uint32_t
#include <string>
#include <bitset>
#include <random>
#include <cmath>

#define ln2 0x3f317218;


using namespace std;

//xoroshiro rng for testing

static inline uint32_t rotl(const uint32_t x, int k) {
	return (x << k) | (x >> (32 - k));
}


static uint32_t s[4];

uint32_t next(void) {
	const uint32_t result = s[0] + s[3];

	const uint32_t t = s[1] << 9;

	s[2] ^= s[0];
	s[3] ^= s[1];
	s[1] ^= s[2];
	s[0] ^= s[3];

	s[2] ^= t;

	s[3] = rotl(s[3], 11);

	return result;
}

uint32_t bounded_rand(uint32_t range) {
    uint32_t x = next();
    uint64_t m = uint64_t(x) * uint64_t(range);
    return m >> 32;
}

unsigned int clz(unsigned int num) {
    return __builtin_clz(num);
}

unsigned int ctz(unsigned int num) {
    return __builtin_ctz(num);
}


float foofastlog (unsigned int x) {
    unsigned int b = 32 - clz(x) - 1;
    float rem = x & ((1<<(b))-1);
    rem = rem/(1<<b); //division
    return float(b + rem) * 0x3f317218 - 32;
    
}

float fff(uint32_t x) {
    unsigned int b = 32 - clz(x) - 1;
    float rem = x & ((1<<(b))-1);
    rem = abs(rem/(1<<b)); //division
    //cout << "b+rem: " << b+rem << endl;
    return (b + rem - .3463 * (rem*rem - rem));

}

float nfff(uint32_t x) {
    return -.69314718056*(fff(x) - 32);
}


float fastlog3(uint32_t x) {
    if (x==2147483648) {
         cout << x;
    }
    unsigned int b = 32 - clz(x) - 1;
    float rem = ( x & ((1<<(b))-1) );
    if (b!=31) {
        rem = rem/(1<<b); //division
    }
    else {
        rem = x * 0x1.0p-31 - 1 ;
    }
    float c3 = .1307;
    float c2 = -.5375;
    float c1 = 1.4068;
    float rv = float(b) - 32 + c3 * rem * rem * rem + c2 * rem * rem + c1 * rem;
    return rv;
}
float nf3(uint32_t x) {
    return -.69314718056*(fastlog3(x));
}

float foofasterlog (uint32_t x) {
    float out = 0;
    uint32_t clz0 = clz(x);
    uint32_t clz1 = 31 - clz0;
    //cout << "clz1: " << clz1 << endl;
    auto clz2 = 32 - clz(clz1);
    //cout << "clz2: " << clz2 << endl;
    x = (127 + clz2-1) << 23 | (clz1 ^ (1<<(clz2-1))) << (24 - clz2) | (x  << (clz0+1) ) >> (8+clz2);
    //cout << "fflx: ";
    //printint(x);
    //cout << endl;
    memcpy(&out, &x, sizeof(out));
    return  out;
}

double exp1_(double x) { 
    return (6+x*(6+x*(3+x)))*0.16666666f; 
}


volatile float result = 0;

int main() { 
    
    size_t iters = 4294967295;
    iters = 1e6;
    vector<float> fvec ;
    vector<int> ivec ;

    

    float T = 1.0;
    float b = 1/T;

    int counter = 0;
    random_device rd;
    for(int i = 0; i < 4; ++i) {
        s[i] = rd();
    }
    //s[0] = 245234;
    //s[1] = 232342423;
    //s[2] = 789273;
    //s[3] = 839;
    

    for(size_t i = 0; i < iters; ++i) {
        fvec.push_back( bounded_rand(10) - 5);
        ivec.push_back( bounded_rand(10) - 5) ;
    }

    
    auto start = std::chrono::high_resolution_clock::now();
    size_t trials = 1000;
   
    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed = end - start;
    float t1 = elapsed.count();
    


    counter = 0;
    vector<int> logcounts;
    for(int i = 0; i < 34; i++) {
        logcounts.push_back(0);
    }

    
    uint32_t f = 2524468831;
    cout << "a/2^32 = " << 0x1.0p-32 * f << endl;
    cout << fastlog3(f) << endl;
    cout << foofastlog(f) << endl;
    cout  << ": " << -.69314718056*(fastlog3(f) - 32)  << " " << - log( 0x1.0p-32 * f ) << "\n";
    double error=0;
    //for(uint32_t i = 0; i < 4 294 967 295; i++) {
    uint32_t numiters = 4294967295;
    float maxerr = 0;
    //500000000
    //2524468820
    for(uint32_t i = 4294967295; i < numiters; i++) {
        if (i == 253){
            cout << i;
        }
        auto partial = abs( fastlog3(i) - log2( 0x1.0p-32 *i) );
        if (partial > maxerr) maxerr = partial;
        //cout << partial << endl;
        if (partial > .005) {
            cout << "large error at i = " << i << "\n" << "log is " << log2( 0x1.0p-32 *i) << " calclog is " << fastlog3(i) ;
            cout << "error is " << partial << endl;
            //break;
        }
        error += partial / numiters ;
        if(isnan(error)) {
            cout << "nan error at i = " << i << "\n" << "log is " << log2( 0x1.0p-32 *i);
            break;
        }

        if (i % 100000000 == 0 ) cout<< 100*float(i)/numiters << " percent done" << endl;
    }
    std::cout << "\n\navg error = " << error*100 << " percent" << endl;
    cout << "max error = " << maxerr << endl;
   

   

    start = std::chrono::high_resolution_clock::now();
    for (size_t j = 0; j < trials; ++j) {
        for(uint i = 1; i < iters; ++i) {
            counter +=   fvec[i] * b <  ( nf3(i) ) ;
        }
    }
    end = std::chrono::high_resolution_clock::now();
    elapsed = end - start;
    float t2 = elapsed.count();
    std::cout << "Elapsed time nf3: " << t2 << " seconds" << std::endl;
    cout << "counter is " << counter << endl;

    counter = 0;
    
    start = std::chrono::high_resolution_clock::now();
    for (size_t j = 0; j < trials; ++j) {
        for(uint i = 1; i < iters; ++i) {
            //auto randint = next();
            counter +=   exp1_(-(fvec[i] / T)) >  0x1.0p-32 * next()  ;
        }
    }
    end = std::chrono::high_resolution_clock::now();
    elapsed = end - start;

    std::cout << "Elapsed time exp: " << elapsed.count() << " seconds" << std::endl;
    cout << "counter is " << counter << endl;

    size_t errors = 0;
    for (size_t j = 0; j < trials; ++j) {
        for(uint i = 1; i < 10; ++i) {
            auto randint = next();
            //if ( fvec[i] * b < ( nf3(randint) ) != (exp(-(fvec[i] / T)) >  0x1.0p-32 * randint  )) {
            //if ( (exp1_(-(fvec[i] / T)) >  0x1.0p-32 * randint  ) != (exp(-(fvec[i] / T)) >  0x1.0p-32 * randint  )) {
                
                ++errors;
            }
            
        }
    }
    cout << errors << "total errors" << endl;
    cout << (float)errors/(trials * iters) * 100 << "% error." << endl;

    std::cout  << "Ratio: " << t2 / elapsed.count() << std::endl;



    
        
    return 0;

}

