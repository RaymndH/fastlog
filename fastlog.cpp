///////////// Code to calculate log base 2 of an unsigned int (such as generated by an rng)
#include <stdio.h>
#include <stdint.h>
#include <iostream>
#include <chrono>
#include <string>
#include <inttypes.h> // for uint32_t
#include <string>
#include <bitset>
#include <random>

#define ln2 0x3f317218;


using namespace std;

//xoroshiro rng for testing

static inline uint32_t rotl(const uint32_t x, int k) {
	return (x << k) | (x >> (32 - k));
}


static uint32_t s[4];

uint32_t next(void) {
	const uint32_t result = s[0] + s[3];

	const uint32_t t = s[1] << 9;

	s[2] ^= s[0];
	s[3] ^= s[1];
	s[1] ^= s[2];
	s[0] ^= s[3];

	s[2] ^= t;

	s[3] = rotl(s[3], 11);

	return result;
}

uint32_t bounded_rand(uint32_t range) {
    uint32_t x = next();
    uint64_t m = uint64_t(x) * uint64_t(range);
    return m >> 32;
}



void floatToBinary(float f, string& str)
{
    union { float f; uint32_t i; } u;
    u.f = f;
    str.clear();

    for (int i = 0; i < 32; i++)
    {
        if (u.i % 2)  str.push_back('1');
        else str.push_back('0');
        u.i >>= 1;
    }

    // Reverse the string since now it's backwards
    string temp(str.rbegin(), str.rend());
    temp.insert(9,  " ");
    temp.insert(1,  " ");
    str = temp;
}

unsigned int clz(unsigned int num) {
    return __builtin_clz(num);
}

unsigned int ctz(unsigned int num) {
    return __builtin_ctz(num);
}

//unsigned int bsr(unsigned int num) {
//    return __builtin_bsr(num);
//}

void printint(unsigned a) {
    std::bitset<32> x(a);
    std::cout << x << endl;
}

float foofastlog (unsigned int x) {
    unsigned int b = 32 - clz(x) - 1;
    float rem = x & ((1<<(b))-1);
    rem = rem/(1<<b); //division
    return float(b + rem) * 0x3f317218 - 32;
    
}

float fff(uint32_t x) {
    unsigned int b = 32 - clz(x) - 1;
    float rem = x & ((1<<(b))-1);
    rem = abs(rem/(1<<b)); //division
    //cout << "b+rem: " << b+rem << endl;
    return (b + rem - .3463 * (rem*rem - rem));

}

float fff2(uint32_t x) {

    unsigned int b = 32 - clz(x) - 1;
    float rem = ( x & ((1<<(b))-1) ) >> b;
    rem = abs(rem); //division
    //cout << "rem is: " << rem << endl;
    return (b + 1.3463 * rem - .3463 * rem * rem);

}

float foofasterlog (uint32_t x) {
    float out = 0;
    uint32_t clz0 = clz(x);
    uint32_t clz1 = 31 - clz0;
    //cout << "clz1: " << clz1 << endl;
    auto clz2 = 32 - clz(clz1);
    //cout << "clz2: " << clz2 << endl;
    x = (127 + clz2-1) << 23 | (clz1 ^ (1<<(clz2-1))) << (24 - clz2) | (x  << (clz0+1) ) >> (8+clz2);
    //cout << "fflx: ";
    //printint(x);
    //cout << endl;
    memcpy(&out, &x, sizeof(out));
    return  out;
}

double exp1_(double x) { 
    return (6+x*(6+x*(3+x)))*0.16666666f; 
}


volatile float result = 0;

int main() { 
    unsigned int x = 832849138; // 255 is 2^8 - 1 =  0(*24) 1(*8) log2 is 7.99
    cout << "bits: ";
     printint(x);
     cout << endl;
    cout << "log2 is " << log2(x) << endl;
    
    cout << "fff is " << fff(x) << endl;
    cout << "fff2 is " << fff2(x) << endl;
    //float fx = x * (1>>32);
    cout << "normalized x is" << x << endl;
    cout << "ln x is " << log(x) << endl;
    size_t iters = 4294967295;
    iters = 1e5;
    vector<float> fvec ;
    vector<int> ivec ;

    

    float T = 1.0;
    float b = 1/T;

    int counter = 0;
    random_device rd;
    for(int i = 0; i < 4; ++i) {
        s[i] = rd();
    }
    s[0] = 245234;
    s[1] = 232342423;
    s[2] = 789273;
    s[3] = 839;
    

    for(size_t i = 0; i < iters; ++i) {
        fvec.push_back( bounded_rand(10) - 5);
        ivec.push_back( bounded_rand(10) - 5) ;
    }

    
    float dump = 0;
    auto start = std::chrono::high_resolution_clock::now();
    size_t trials = 1000;
    for (size_t j = 0; j < trials; ++j) {
        for(uint i = 1; i < iters; ++i) {
            counter +=  exp(-(fvec[i] / T)) >  0x1.0p-32 * next()  ;
        }
    }
    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed = end - start;
    float t1 = elapsed.count();
    std::cout << "Elapsed time: " << elapsed.count() << " seconds" << std::endl;
    cout << "counter is " << counter << endl;


    counter = 0;
    vector<int> logcounts;
    for(int i = 0; i < 34; i++) {
        logcounts.push_back(0);
    }

    /*
    uint32_t f = 3579644072;
    cout << "a/2^32 = " << 0x1.0p-32 * f;
    cout << fff2(f) << endl;
    cout  << ": " << -.69314718056*(fff2(f) - 32)  << " " << - log( 0x1.0p-32 * f ) << "\n";
    for(int i = 0; i < 10; i++) {
        //logcounts[int(foofastlog(next()))]++;
        auto a = next();
        cout << "a: " << a << endl;
        cout << "a/2^32 = " << 0x1.0p-32 * a;
        cout << i << ": " << -.69314718056*(fff2(a) - 32)  << " " << - log( 0x1.0p-32 * a ) << "\n";
        //cout << i << ": " << .69314718056  * fff(a)  << " " << - log( (double)(next()) / (2L << 31) ) << "\n";
    }*/
   

   

    start = std::chrono::high_resolution_clock::now();
    for (size_t j = 0; j < trials; ++j) {
        for(uint i = 1; i < iters; ++i) {
            counter +=   fvec[i] * b <  (-.69314718056*(fff(next()) - 32) ) ;
        }
    }
    end = std::chrono::high_resolution_clock::now();
    elapsed = end - start;
    float t2 = elapsed.count();
    std::cout << "Elapsed time: " << t2 << " seconds" << std::endl;
    cout << "counter is " << counter << endl;

    counter = 0;
    
    start = std::chrono::high_resolution_clock::now();
    for (size_t j = 0; j < trials; ++j) {
        for(uint i = 1; i < iters; ++i) {
            auto randint = next();
            counter +=   fvec[i] * b < (-.69314718056*(fff2(next()) - 32) ) ;
        }
    }
    end = std::chrono::high_resolution_clock::now();
    elapsed = end - start;

    std::cout << "Elapsed time: " << elapsed.count() << " seconds" << std::endl;
    cout << "counter is " << counter << endl;

    size_t errors = 0;
    for (size_t j = 0; j < trials; ++j) {
        for(uint i = 1; i < iters; ++i) {
            auto randint = next();
            if ( fvec[i] * b < (-.69314718056*(fff2(randint) - 32) ) != (exp(-(fvec[i] / T)) >  0x1.0p-32 * randint  )) {
                ++errors;
            }
        }
    }

    cout << (float)errors/(trials * iters) * 100 << "% error." << endl;

    std::cout  << "Ratio: " << abs(t1 - 0) / elapsed.count() << std::endl;



    
        
    return 0;

}

